# 后端开发规范文档

## 一、代码组织规范

### 1.1 文件命名规范

**Models层**：
- 文件名使用单数形式：`user.py`, `agent.py`
- 类名使用PascalCase：`User`, `Agent`

**Schemas层**：
- 文件名使用单数形式：`user.py`, `agent.py`
- 类名使用PascalCase：`UserCreate`, `AgentUpdate`

**Services层**：
- 简单领域：`{domain}_service.py`（如`user_service.py`）
- 复杂领域：`{domain}/`目录，内部文件按职责命名：
  - `core.py` - 核心执行逻辑
  - `business.py` - 业务逻辑
  - `admin.py` - 管理功能
  - `dao.py` - 数据访问

**Routers层**：
- 文件名使用单数形式：`agent.py`, `user.py`
- 路由变量名：`router`（单文件）或`router_v1`, `router_v2`（多版本）

### 1.2 目录结构规范

**简单领域（单文件）**：
- 服务文件数量 ≤ 2个
- 职责单一，无明显分离
- 示例：`services/user_service.py`

**复杂领域（子目录）**：
- 服务文件数量 ≥ 3个
- 有明显职责分离
- 示例：`services/agent/`, `services/conversation/`

### 1.3 领域划分标准

根据以下标准判断领域复杂度：

1. **服务文件数量**：≥ 3个文件使用子目录
2. **职责分离**：有明显分离（core/business/admin/dao）使用子目录
3. **代码行数**：单个文件超过500行考虑拆分

## 二、导入规范

### 2.1 导入顺序

```python
# 1. 标准库
from typing import Optional, List, Dict
from datetime import datetime
from decimal import Decimal

# 2. 第三方库
from sqlalchemy import select, func
from sqlalchemy.ext.asyncio import AsyncSession
from fastapi import APIRouter, Depends
from loguru import logger

# 3. 本地库（按层次顺序）
# 3.1 基础设施层
from infrastructure.core.config import settings
from infrastructure.core.deps import get_db

# 3.2 数据模型层
from models.agent import Agent
from models.user import User

# 3.3 Schema层
from schemas.agent import AgentCreate, AgentUpdate

# 3.4 服务层
from services.agent.business import AgentBusinessService
from services.shared.llm_service import LLMFactory

# 3.5 工具层
from utils.exceptions import NotFoundException, BadRequestException
from utils.response import success, fail
```

### 2.2 导入路径规范

- **使用绝对导入**：`from models.agent import Agent`
- **避免相对导入**：不使用`from ..models import Agent`
- **导入路径清晰**：体现层次关系

### 2.3 循环导入处理

如果出现循环导入，使用延迟导入：

```python
# 在方法内部导入
async def some_method(self):
    from services.other import OtherService
    service = OtherService(self.db)
```

## 三、注释规范

### 3.1 模块级注释

每个Python文件开头必须有模块级文档字符串：

```python
"""
模块名称
模块功能描述

关键设计决策说明：
- 为什么这样设计
- 关键实现细节

使用示例：
    from services.agent.business import AgentBusinessService
    service = AgentBusinessService(db)
"""
```

### 3.2 类级注释

每个类必须有类级文档字符串：

```python
class AgentBusinessService:
    """
    Agent业务服务类
    
    职责说明：
    - 权限验证：验证用户是否有权限使用Agent
    - 余额检查：检查用户余额是否充足
    - 会话管理：创建和管理对话会话
    - 业务编排：调用Agent核心执行服务
    
    依赖关系：
    - 依赖AgentCoreService（核心执行）
    - 依赖ConversationBusinessService（会话管理）
    - 依赖CoinAccountService（余额检查）
    
    使用示例：
        service = AgentBusinessService(db)
        async for chunk in service.execute_agent(
            agent_id=1,
            user_id=1,
            input_text="你好"
        ):
            print(chunk)
    """
```

### 3.3 方法级注释

每个公共方法必须有方法级文档字符串：

```python
async def execute_agent(
    self,
    agent_id: int,
    user_id: int,
    project_id: int,
    input_text: str,
    enable_persona: bool = True,
    conversation_id: Optional[int] = None
) -> AsyncGenerator[str, None]:
    """
    执行Agent（完整业务流程）
    
    业务逻辑流程：
    1. 验证用户权限（是否有权限使用该Agent）
    2. 验证项目权限（用户是否拥有该项目）
    3. 检查余额（通过CoinAccountService）
    4. 创建/获取会话（通过ConversationBusinessService）
    5. 调用Agent核心执行（通过AgentCoreService）
    6. 保存对话记录
    7. 更新统计信息
    
    Args:
        agent_id: Agent ID
        user_id: 用户ID
        project_id: 项目ID
        input_text: 用户输入文本
        enable_persona: 是否启用IP基因注入，默认True
        conversation_id: 会话ID，如果为None则创建新会话
    
    Yields:
        流式输出的文本块（str）
    
    Raises:
        NotFoundException: Agent不存在或未上架
        BadRequestException: 余额不足或权限不足
        ValueError: 输入参数无效
    
    使用示例：
        service = AgentBusinessService(db)
        async for chunk in service.execute_agent(
            agent_id=1,
            user_id=1,
            project_id=1,
            input_text="你好"
        ):
            print(chunk, end="")
    """
```

### 3.4 行内注释

关键业务逻辑必须有行内注释：

```python
# 验证用户权限
if not await self._verify_user_permission(user_id, agent_id):
    raise ForbiddenException("用户无权限使用该Agent")

# 检查余额（预冻结）
freeze_info = await self.coin_service.check_and_freeze(
    user_id=user_id,
    model_id=agent.model_id,
    estimated_tokens=max_tokens
)
```

## 四、类型注解规范

### 4.1 函数参数和返回值

所有函数必须有完整的类型注解：

```python
async def get_agent_by_id(
    self,
    agent_id: int,
    user_id: Optional[int] = None
) -> Agent:
    """
    根据ID获取Agent
    
    Args:
        agent_id: Agent ID
        user_id: 用户ID（可选，用于权限验证）
    
    Returns:
        Agent对象
    
    Raises:
        NotFoundException: Agent不存在
    """
```

### 4.2 复杂类型

使用typing模块定义复杂类型：

```python
from typing import List, Dict, Optional, Tuple, AsyncGenerator

async def list_agents(
    self,
    page: int = 1,
    size: int = 20
) -> Tuple[List[Agent], int]:
    """
    获取Agent列表
    
    Returns:
        (Agent列表, 总数)
    """
```

## 五、错误处理规范

### 5.1 异常类型

使用自定义异常类：

```python
from utils.exceptions import (
    NotFoundException,
    BadRequestException,
    ForbiddenException,
    UnauthorizedException
)

# 使用示例
if not agent:
    raise NotFoundException(f"Agent {agent_id} 不存在")

if agent.status != 1:
    raise BadRequestException("Agent未上架")
```

### 5.2 异常消息

异常消息要清晰明确：

```python
# 好的示例
raise NotFoundException(f"Agent {agent_id} 不存在")
raise BadRequestException(f"余额不足，需要 {required_amount} 火源币，当前余额 {current_balance}")

# 不好的示例
raise NotFoundException("不存在")
raise BadRequestException("错误")
```

## 六、响应格式规范

### 6.1 统一响应格式

所有API接口必须返回统一格式：`{code, data, msg}`

```python
from utils.response import success, fail, page_response

# 成功响应
return success(data=agent, msg="获取成功")

# 失败响应
return fail(msg="Agent不存在", code=404)

# 分页响应
return page_response(
    items=agents,
    total=total,
    page_num=page,
    page_size=size
)
```

### 6.2 禁止行为

- ❌ 直接返回原始数据：`return {"id": 1}`
- ❌ 使用FastAPI默认响应格式
- ❌ 返回不包含code、data、msg字段的响应

## 七、数据库操作规范

### 7.1 使用异步操作

所有数据库操作必须使用异步方式：

```python
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

async def get_agent(self, agent_id: int) -> Agent:
    result = await self.db.execute(
        select(Agent).where(Agent.id == agent_id)
    )
    return result.scalar_one_or_none()
```

### 7.2 事务管理

使用数据库会话管理事务：

```python
async def create_agent(self, data: AgentCreate) -> Agent:
    agent = Agent(**data.dict())
    self.db.add(agent)
    await self.db.flush()  # 刷新到数据库，获取ID
    await self.db.refresh(agent)  # 刷新对象，获取完整数据
    return agent
```

### 7.3 查询优化

- 使用selectinload避免N+1查询
- 使用索引优化查询性能
- 避免全表扫描

## 八、业务逻辑规范

### 8.1 职责分离

**Core服务（纯技术）**：
- 不涉及业务逻辑（权限、余额等）
- 只负责技术实现（路由、Prompt、LLM调用）

**Business服务（业务逻辑）**：
- 负责业务逻辑（权限验证、余额检查）
- 调用Core服务执行
- 管理会话和统计

**DAO服务（数据访问）**：
- 只负责CRUD操作
- 不包含业务逻辑
- 可以包含查询优化

### 8.2 防御性编程

- 参数验证：验证所有输入参数
- 空值检查：检查可能为None的值
- 异常处理：捕获并处理所有可能的异常

```python
async def execute_agent(self, agent_id: int, user_id: int, input_text: str):
    # 参数验证
    if not input_text or not input_text.strip():
        raise BadRequestException("用户输入不能为空")
    
    # 获取Agent
    agent = await self.get_agent(agent_id)
    if not agent:
        raise NotFoundException(f"Agent {agent_id} 不存在")
    
    # 状态检查
    if agent.status != 1:
        raise BadRequestException("Agent未上架")
    
    # 业务逻辑...
```

## 九、AI辅助开发最佳实践

### 9.1 文件命名清晰

- 文件名体现领域和职责
- 避免通用名称（service.py, handler.py）
- 使用有意义的名称（agent_business_service.py）

### 9.2 导入路径直观

- 导入路径体现层次关系
- 避免深层嵌套导入
- 使用绝对导入

### 9.3 注释完整

- 每个类和方法都有文档字符串
- 关键业务逻辑有行内注释
- 复杂算法有详细说明

### 9.4 代码结构清晰

- 职责单一，每个类只负责一个职责
- 业务逻辑与技术实现分离
- 数据访问与业务逻辑分离

### 9.5 类型注解完整

- 所有函数参数和返回值都有类型注解
- 使用typing模块定义复杂类型
- 帮助AI理解代码结构

## 十、代码审查清单

在提交代码前，确保：

- [ ] 文件命名符合规范
- [ ] 导入路径正确，无循环导入
- [ ] 所有类和方法都有文档字符串
- [ ] 类型注解完整
- [ ] 错误处理完善
- [ ] 响应格式统一
- [ ] 数据库操作使用异步
- [ ] 业务逻辑与技术实现分离
- [ ] 代码风格统一
- [ ] 无未使用的导入和代码

## 十一、常见问题

### Q1: 如何判断是否需要创建子目录？

A: 如果某个领域有3个以上服务文件，或者有明显的职责分离（core/business/admin/dao），使用子目录。

### Q2: 如何处理版本管理？

A: Schema版本使用命名空间区分，路由版本在main.py中统一管理前缀。

### Q3: 如何避免循环导入？

A: 使用延迟导入（在方法内部导入），或者重新设计依赖关系。

### Q4: 如何确保API路径不变？

A: 路径前缀在main.py中统一管理，路由文件内部路径保持不变。

### Q5: 如何添加新领域？

A: 按照架构文档中的扩展指南，依次添加models、schemas、services、routers文件。

